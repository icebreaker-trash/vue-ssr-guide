<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>Vue SSR Guide and Practice</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta data-n-head="ssr" data-hid="description" name="description" content="Vue SSR Guide and Practice"><meta data-n-head="ssr" data-hid="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,minimal-ui"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><noscript data-n-head="ssr">The page need javascript</noscript><base href="/vue-ssr-guide/"><link rel="preload" href="/vue-ssr-guide/_nuxt/09e86da3d465018d830f.js" as="script"><link rel="preload" href="/vue-ssr-guide/_nuxt/ec8fdd6f260143bf019e.js" as="script"><link rel="preload" href="/vue-ssr-guide/_nuxt/a7b495acccdbcbb9cbf8.js" as="script"><link rel="preload" href="/vue-ssr-guide/_nuxt/5c5760cfebb57e9a3e38.js" as="script"><style data-vue-ssr-id="57312d8d:0 47bbb88e:0 70ec8e52:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;-webkit-transition:width .1s,opacity .4s;transition:width .1s,opacity .4s;background-color:#000;z-index:999999}.nuxt-progress.nuxt-progress-notransition{-webkit-transition:none;transition:none}.nuxt-progress-failed{background-color:red}.doc-container[data-v-b2512a50]{padding-bottom:50px}.controls[data-v-9a4e02f8]{position:fixed;bottom:0;left:0;right:0;color:grey;opacity:.8}.controls .btn[data-v-9a4e02f8]{height:48px}.controls .btn.prev[data-v-9a4e02f8]{width:38%}.controls .btn.next[data-v-9a4e02f8]{width:61%}</style>
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><section class="doc-container" data-v-b2512a50><div data-v-b2512a50><h1 id="客户端激活-client-side-hydration">客户端激活 (client-side hydration)</h1>
<p>所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。</p>
<p>在 <code>entry-client.js</code> 中，我们用下面这行挂载(mount)应用程序：</p>
<pre><code class="language-js">// 这里假定 App.vue template 根元素的 `id="app"`
app.$mount('#app')</code></pre>
<p>由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要"激活"这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。</p>
<p>如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性：</p>
<pre><code class="language-html">&lt;div id="app" data-server-rendered="true"></code></pre>
<p><code>data-server-rendered</code> 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载。注意，这里并没有添加 <code>id="app"</code>，而是添加 <code>data-server-rendered</code> 属性：你需要自行添加 ID 或其他能够选取到应用程序根元素的选择器，否则应用程序将无法正常激活。</p>
<p>注意，在没有 <code>data-server-rendered</code> 属性的元素上，还可以向 <code>$mount</code> 函数的 <code>hydrating</code> 参数位置传入 <code>true</code>，来强制使用激活模式(hydration)：</p>
<pre><code class="language-js">// 强制使用应用程序的激活模式
app.$mount('#app', true)</code></pre>
<p>在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树 (virtual DOM tree)，是否与从服务器渲染的 DOM 结构 (DOM structure) 匹配。如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。<strong>在生产模式下，此检测会被跳过，以避免性能损耗。</strong></p>
<h3 id="一些需要注意的坑">一些需要注意的坑</h3>
<p>使用「SSR + 客户端混合」时，需要了解的一件事是，浏览器可能会更改的一些特殊的 HTML 结构。例如，当你在 Vue 模板中写入：</p>
<pre><code class="language-html">&lt;table>
  &lt;tr>&lt;td>hi&lt;/td>&lt;/tr>
&lt;/table></code></pre>
<p>浏览器会在 <code>&lt;table></code> 内部自动注入 <code>&lt;tbody></code>，然而，由于 Vue 生成的虚拟 DOM (virtual DOM) 不包含 <code>&lt;tbody></code>，所以会导致无法匹配。为能够正确匹配，请确保在模板中写入有效的 HTML。</p>
</div> <div class="controls" data-v-9a4e02f8 data-v-b2512a50><a href="/vue-ssr-guide/6" data-v-9a4e02f8><button class="btn prev" data-v-9a4e02f8>
      上一页
    </button></a> <a href="/vue-ssr-guide/8" data-v-9a4e02f8><button class="btn next" data-v-9a4e02f8>
      下一页
    </button></a></div></section></div></div><script>window.__NUXT__={layout:"default",data:[{sourceIndex:6,sourceLength:15,source:'<h1 id="客户端激活-client-side-hydration">客户端激活 (client-side hydration)</h1>\n<p>所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。</p>\n<p>在 <code>entry-client.js</code> 中，我们用下面这行挂载(mount)应用程序：</p>\n<pre><code class="language-js">// 这里假定 App.vue template 根元素的 `id=&quot;app&quot;`\napp.$mount(&#39;#app&#39;)</code></pre>\n<p>由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要&quot;激活&quot;这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。</p>\n<p>如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性：</p>\n<pre><code class="language-html">&lt;div id=&quot;app&quot; data-server-rendered=&quot;true&quot;&gt;</code></pre>\n<p><code>data-server-rendered</code> 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载。注意，这里并没有添加 <code>id=&quot;app&quot;</code>，而是添加 <code>data-server-rendered</code> 属性：你需要自行添加 ID 或其他能够选取到应用程序根元素的选择器，否则应用程序将无法正常激活。</p>\n<p>注意，在没有 <code>data-server-rendered</code> 属性的元素上，还可以向 <code>$mount</code> 函数的 <code>hydrating</code> 参数位置传入 <code>true</code>，来强制使用激活模式(hydration)：</p>\n<pre><code class="language-js">// 强制使用应用程序的激活模式\napp.$mount(&#39;#app&#39;, true)</code></pre>\n<p>在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树 (virtual DOM tree)，是否与从服务器渲染的 DOM 结构 (DOM structure) 匹配。如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。<strong>在生产模式下，此检测会被跳过，以避免性能损耗。</strong></p>\n<h3 id="一些需要注意的坑">一些需要注意的坑</h3>\n<p>使用「SSR + 客户端混合」时，需要了解的一件事是，浏览器可能会更改的一些特殊的 HTML 结构。例如，当你在 Vue 模板中写入：</p>\n<pre><code class="language-html">&lt;table&gt;\n  &lt;tr&gt;&lt;td&gt;hi&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;</code></pre>\n<p>浏览器会在 <code>&lt;table&gt;</code> 内部自动注入 <code>&lt;tbody&gt;</code>，然而，由于 Vue 生成的虚拟 DOM (virtual DOM) 不包含 <code>&lt;tbody&gt;</code>，所以会导致无法匹配。为能够正确匹配，请确保在模板中写入有效的 HTML。</p>\n'}],error:null,serverRendered:!0}</script><script src="/vue-ssr-guide/_nuxt/09e86da3d465018d830f.js" defer></script><script src="/vue-ssr-guide/_nuxt/5c5760cfebb57e9a3e38.js" defer></script><script src="/vue-ssr-guide/_nuxt/ec8fdd6f260143bf019e.js" defer></script><script src="/vue-ssr-guide/_nuxt/a7b495acccdbcbb9cbf8.js" defer></script>
  </body>
</html>
