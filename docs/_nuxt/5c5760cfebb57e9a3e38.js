(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{149:function(e,n,t){var content=t(158);"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(70).default)("70ec8e52",content,!0,{sourceMap:!1})},150:function(e,n,t){var content=t(176);"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(70).default)("47bbb88e",content,!0,{sourceMap:!1})},157:function(e,n,t){"use strict";var r=t(149);t.n(r).a},158:function(e,n,t){(n=t(69)(!1)).push([e.i,".controls[data-v-9a4e02f8]{position:fixed;bottom:0;left:0;right:0;color:grey;opacity:.8}.controls .btn[data-v-9a4e02f8]{height:48px}.controls .btn.prev[data-v-9a4e02f8]{width:38%}.controls .btn.next[data-v-9a4e02f8]{width:61%}",""]),e.exports=n},159:function(e,n,t){var map={"./zh/README.md":160,"./zh/api/README.md":161,"./zh/guide/README.md":162,"./zh/guide/build-config.md":163,"./zh/guide/bundle-renderer.md":164,"./zh/guide/caching.md":165,"./zh/guide/css.md":166,"./zh/guide/data.md":167,"./zh/guide/head.md":168,"./zh/guide/hydration.md":169,"./zh/guide/non-node.md":170,"./zh/guide/routing.md":171,"./zh/guide/streaming.md":172,"./zh/guide/structure.md":173,"./zh/guide/universal.md":174};function r(e){var n=o(e);return t(n)}function o(e){if(!t.o(map,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return map[e]}r.keys=function(){return Object.keys(map)},r.resolve=o,e.exports=r,r.id=159},160:function(e,n){e.exports='<h1 id="vuejs-服务器端渲染指南">Vue.js 服务器端渲染指南</h1>\n<p>::: tip 注意\n本指南需要最低为如下版本的 Vue，以及以下 library 支持：</p>\n<ul>\n<li>vue &amp; vue-server-renderer 2.3.0+</li>\n<li>vue-router 2.5.0+</li>\n<li>vue-loader 12.0.0+ &amp; vue-style-loader 3.0.0+</li>\n</ul>\n<p>如果先前已经使用过 Vue 2.2 的服务器端渲染 (SSR)，你应该注意到，推荐的代码结构现在<a href="./guide/structure.md">略有不同</a>（使用新的 <a href="./api/README.md#runinnewcontext">runInNewContext</a> 选项，并设置为 <code>false</code>）。现有的应用程序可以继续运行，但建议你迁移到新的推荐规范。\n:::</p>\n<h2 id="什么是服务器端渲染-ssr？">什么是服务器端渲染 (SSR)？</h2>\n<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。</p>\n<p>服务器渲染的 Vue.js 应用程序也可以被认为是&quot;同构&quot;或&quot;通用&quot;，因为应用程序的大部分代码都可以在<strong>服务器</strong>和<strong>客户端</strong>上运行。</p>\n<h2 id="为什么使用服务器端渲染-ssr？">为什么使用服务器端渲染 (SSR)？</h2>\n<p>与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：</p>\n<ul>\n<li><p>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</p>\n<p>请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。</p>\n</li>\n<li><p>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。</p>\n</li>\n</ul>\n<p>使用服务器端渲染 (SSR) 时还需要有一些权衡之处：</p>\n<ul>\n<li><p>开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。</p>\n</li>\n<li><p>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</p>\n</li>\n<li><p>更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>\n</li>\n</ul>\n<p>在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染 (SSR) 可以帮助你实现最佳的初始加载性能。</p>\n<h2 id="服务器端渲染-vs-预渲染-ssr-vs-prerendering">服务器端渲染 vs 预渲染 (SSR vs Prerendering)</h2>\n<p>如果你调研服务器端渲染 (SSR) 只是用来改善少数营销页面（例如 <code>/</code>, <code>/about</code>, <code>/contact</code> 等）的 SEO，那么你可能需要<strong>预渲染</strong>。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。</p>\n<p>如果你使用 webpack，你可以使用 <a href="https://github.com/chrisvfritz/prerender-spa-plugin">prerender-spa-plugin</a> 轻松地添加预渲染。它已经被 Vue 应用程序广泛测试 - 事实上，<a href="https://github.com/chrisvfritz">作者</a>是 Vue 核心团队的成员。</p>\n<h2 id="关于此指南">关于此指南</h2>\n<p>本指南专注于，使用 Node.js server 的服务器端单页面应用程序渲染。将 Vue 服务器端渲染 (SSR) 与其他后端设置进行混合使用，是后端自身集成 SSR 的话题，我们会在 <a href="./guide/non-node.md">专门章节</a> 中进行简要讨论。</p>\n<p>本指南将会非常深入，并且假设你已经熟悉 Vue.js 本身，并且具有 Node.js 和 webpack 的相当不错的应用经验。如果你倾向于使用提供了平滑开箱即用体验的更高层次解决方案，你应该去尝试使用 <a href="https://nuxtjs.org/">Nuxt.js</a>。它建立在同等的 Vue 技术栈之上，但抽象出很多模板，并提供了一些额外的功能，例如静态站点生成。但是，如果你需要更直接地控制应用程序的结构，Nuxt.js 并不适合这种使用场景。无论如何，阅读本指南将更有助于更好地了解一切如何运行。</p>\n<p>当你阅读时，参考官方 <a href="https://github.com/vuejs/vue-hackernews-2.0/">HackerNews Demo</a> 将会有所帮助，此示例使用了本指南涵盖的大部分技术。</p>\n<p>最后，请注意，本指南中的解决方案不是限定的 - 我们发现它们对我们来说很好，但这并不意味着无法继续改进。可能会在未来持续改进，欢迎通过随意提交 pull request 作出贡献！</p>\n'},161:function(e,n){e.exports='<hr>\n<h2 id="sidebar-auto">sidebar: auto</h2>\n<h1 id="api-参考">API 参考</h1>\n<h2 id="createrenderer">createRenderer</h2>\n<p>使用（可选的）<a href="#renderer-options">选项</a>创建一个 <a href="#class-renderer"><code>Renderer</code></a> 实例。</p>\n<pre><code class="language-js">const { createRenderer } = require(&#39;vue-server-renderer&#39;)\nconst renderer = createRenderer({ /* 选项 */ })</code></pre>\n<h2 id="createbundlerenderer">createBundleRenderer</h2>\n<p>使用 server bundle 和（可选的）<a href="#renderer-options">选项</a>创建一个 <a href="#class-bundlerenderer"><code>BundleRenderer</code></a> 实例。</p>\n<pre><code class="language-js">const { createBundleRenderer } = require(&#39;vue-server-renderer&#39;)\nconst renderer = createBundleRenderer(serverBundle, { /* 选项 */ })</code></pre>\n<p><code>serverBundle</code> 参数可以是以下之一：</p>\n<ul>\n<li><p>绝对路径，指向一个已经构建好的 bundle 文件（<code>.js</code> 或 <code>.json</code>）。必须以 <code>/</code> 开头才会被识别为文件路径。</p>\n</li>\n<li><p>由 webpack + <code>vue-server-renderer/server-plugin</code> 生成的 bundle 对象。</p>\n</li>\n<li><p>JavaScript 代码字符串（不推荐）。</p>\n</li>\n</ul>\n<p>更多细节请查看 <a href="../guide/bundle-renderer.md">Server Bundle 指引</a> 和 <a href="../guide/build-config.md">构建配置</a>。</p>\n<h2 id="class-renderer">Class: Renderer</h2>\n<h3 id="rendererrendertostring">renderer.renderToString</h3>\n<p>函数签名:</p>\n<pre><code class="language-js">renderer.renderToString(vm, context?, callback?): ?Promise&lt;string&gt;</code></pre>\n<p>将 Vue 实例渲染为字符串。上下文对象 (context object) 可选。回调函数是典型的 Node.js 风格回调，其中第一个参数是可能抛出的错误，第二个参数是渲染完毕的字符串。</p>\n<p>在 2.5.0+ 版本中，此 callback 回调函数是可选项。在不传递 callback 时，此方法返回一个 Promise 对象，在其  resolve 后返回最终渲染的 HTML。</p>\n<h3 id="rendererrendertostream">renderer.renderToStream</h3>\n<p>函数签名:</p>\n<pre><code class="language-js">renderer.renderToStream(vm[, context]): stream.Readable</code></pre>\n<p>将 Vue 实例渲染为一个 <a href="https://nodejs.org/dist/latest-v8.x/docs/api/stream.html#stream_readable_streams">Node.js 可读流</a>。上下文对象 (context object) 可选。更多细节请查看<a href="../guide/streaming.md">流式渲染</a>。</p>\n<h2 id="class-bundlerenderer">Class: BundleRenderer</h2>\n<h3 id="bundlerendererrendertostring">bundleRenderer.renderToString</h3>\n<p>函数签名:</p>\n<pre><code class="language-js">bundleRenderer.renderToString([context, callback]): ?Promise&lt;string&gt;</code></pre>\n<p>将 bundle 渲染为字符串。上下文对象 (context object) 可选。回调是一个典型的 Node.js 风格回调，其中第一个参数是可能抛出的错误，第二个参数是渲染完毕的字符串。</p>\n<p>在 2.5.0+ 版本中，此 callback 回调函数是可选项。在不传递 callback 时，此方法返回一个 Promise 对象，在其  resolve 后返回最终渲染的 HTML。</p>\n<h3 id="bundlerendererrendertostream">bundleRenderer.renderToStream</h3>\n<p>函数签名:</p>\n<pre><code class="language-js">bundleRenderer.renderToStream([context]): stream.Readable</code></pre>\n<p>将 bundle 渲染为一个 <a href="https://nodejs.org/dist/latest-v8.x/docs/api/stream.html#stream_readable_streams">Node.js 可读流</a>。上下文对象 (context object) 可选。更多细节请查看<a href="../guide/streaming.md">流式渲染</a>。</p>\n<h2 id="renderer-选项">Renderer 选项</h2>\n<h3 id="template">template</h3>\n<p>为整个页面的 HTML 提供一个模板。此模板应包含注释 <code>&lt;!--vue-ssr-outlet--&gt;</code>，作为渲染应用程序内容的占位符。</p>\n<p>模板还支持使用渲染上下文 (render context) 进行基本插值：</p>\n<ul>\n<li>使用双花括号 (double-mustache) 进行 HTML 转义插值 (HTML-escaped interpolation)；</li>\n<li>使用三花括号 (triple-mustache) 进行 HTML 不转义插值 (non-HTML-escaped interpolation)。</li>\n</ul>\n<p>当在渲染上下文 (render context) 上存在一些特定属性时，模板会自动注入对应的内容：</p>\n<ul>\n<li><p><code>context.head</code>：（字符串）将会被作为 HTML 注入到页面的头部 (head) 里。</p>\n</li>\n<li><p><code>context.styles</code>：（字符串）内联 CSS，将以 style 标签的形式注入到页面头部。注意，如过你使用了 <code>vue-loader</code> + <code>vue-style-loader</code> 来处理组件 CSS，此属性会在构建过程中被自动生成。</p>\n</li>\n<li><p><code>context.state</code>：（对象）初始 Vuex store 状态，将以 <code>window.__INITIAL_STATE__</code> 的形式内联到页面。内联的 JSON 将使用 <a href="https://github.com/yahoo/serialize-javascript">serialize-javascript</a>  自动清理，以防止 XSS 攻击。</p>\n<p>在 2.5.0+ 版本中，嵌入式 script 也可以也可以在生产模式 (production mode) 下自行移除。</p>\n</li>\n</ul>\n<p>此外，当提供 <code>clientManifest</code> 时，模板会自动注入以下内容：</p>\n<ul>\n<li>渲染当前页面所需的最优客户端 JavaScript 和 CSS 资源（支持自动推导异步代码分割所需的文件）；</li>\n<li>为要渲染页面提供最佳的 <code>&lt;link rel=&quot;preload/prefetch&quot;&gt;</code> 资源提示 (resource hints)。</li>\n</ul>\n<p>你也可以通过将 <code>inject: false</code> 传递给 renderer，来禁用所有自动注入。</p>\n<p>具体查看：</p>\n<ul>\n<li><a href="../guide/#using-a-page-template">使用一个页面模板</a></li>\n<li><a href="../guide/build-config.md#manual-asset-injection">手动资源注入(Manual Asset Injection)</a></li>\n</ul>\n<h3 id="clientmanifest">clientManifest</h3>\n<p>通过此选项提供一个由 <code>vue-server-renderer/client-plugin</code> 生成的客户端构建 manifest 对象(client build manifest object)。此对象包含了 webpack 整个构建过程的信息，从而可以让 bundle renderer 自动推导需要在 HTML 模板中注入的内容。更多详细信息，请查看<a href="../guide/build-config.md#generating-clientmanifest">生成 clientManifest</a>。</p>\n<h3 id="inject">inject</h3>\n<p>控制使用 <code>template</code> 时是否执行自动注入。默认是 <code>true</code>。</p>\n<p>参考：<a href="../guide/build-config.md#manual-asset-injection">手动资源注入(Manual Asset Injection)</a>。</p>\n<h3 id="shouldpreload">shouldPreload</h3>\n<p>一个函数，用来控制什么文件应该生成 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 资源预加载提示 (resource hints)。</p>\n<p>默认情况下，只有 JavaScript 和 CSS 文件会被预加载，因为它们是启动应用时所必需的。</p>\n<p>对于其他类型的资源（如图像或字体），预加载过多可能会浪费带宽，甚至损害性能，因此预加载什么资源具体依赖于场景。你可以使用 <code>shouldPreload</code> 选项精确控制预加载资源：</p>\n<pre><code class="language-js">const renderer = createBundleRenderer(bundle, {\n  template,\n  clientManifest,\n  shouldPreload: (file, type) =&gt; {\n    // 基于文件扩展名的类型推断。\n    // https://fetch.spec.whatwg.org/#concept-request-destination\n    if (type === &#39;script&#39; || type === &#39;style&#39;) {\n      return true\n    }\n    if (type === &#39;font&#39;) {\n      // 只预加载 woff2 字体\n      return /\\.woff2$/.test(file)\n    }\n    if (type === &#39;image&#39;) {\n      // 只预加载重要 images\n      return file === &#39;hero.jpg&#39;\n    }\n  }\n})</code></pre>\n<h3 id="shouldprefetch">shouldPrefetch</h3>\n<ul>\n<li>2.5.0+</li>\n</ul>\n<p>一个函数，用来控制对于哪些文件，是需要生成 <code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 资源提示。</p>\n<p>默认情况下，异步 chunk 中的所有资源都将被预取，因为这是低优先级指令; 然而，为了更好地控制带宽使用情况，你也可以自定义要预取的资源。此选项具有与 <code>shouldPreload</code> 相同的函数签名。</p>\n<h3 id="runinnewcontext">runInNewContext</h3>\n<ul>\n<li>只用于 <code>createBundleRenderer</code></li>\n<li>期望值：<code>boolean | &#39;once&#39;</code>（<code>&#39;once&#39;</code> 只在 2.3.1+ 支持）</li>\n</ul>\n<p>默认情况下，对于每次渲染，bundle renderer 将创建一个新的 V8 上下文并重新执行整个 bundle。这具有一些好处 - 例如，应用程序代码与服务器进程隔离，我们无需担心文档中提到的<a href="../guide/structure.md#avoid-stateful-singletons">状态单例问题</a>。然而，这种模式有一些相当大的性能开销，因为重新创建上下文并执行整个 bundle 还是相当昂贵的，特别是当应用很大的时候。</p>\n<p>出于向后兼容的考虑，此选项默认为 <code>true</code>，但建议你尽可能使用 <code>runInNewContext: false</code> 或 <code>runInNewContext: &#39;once&#39;</code>。</p>\n<blockquote>\n<p>在 2.3.0 中，此选项有一个 bug，其中 <code>runInNewContext: false</code> 仍然使用独立的全局上下文 (separate global context) 执行 bundle。以下信息假定版本为 2.3.1+。</p>\n</blockquote>\n<p>使用 <code>runInNewContext: false</code>，bundle 代码将与服务器进程在同一个 <code>global</code> 上下文中运行，所以请留意在应用程序代码中尽量避免修改 <code>global</code>。</p>\n<p>使用 <code>runInNewContext: &#39;once&#39;</code> (2.3.1+)，bundle 将在独立的<code>全局</code>上下文(separate global context)取值，然而只在启动时取值一次。这提供了一定程度的应用程序代码隔离，因为它能够防止 bundle 中的代码意外污染服务器进程的 <code>global</code> 对象。注意事项如下：</p>\n<ol>\n<li>在此模式下，修改 <code>global</code>（例如，polyfill）的依赖模块必须被打包进 bundle，不能被外部化 (externalize)；</li>\n<li>从 bundle 执行返回的值将使用不同的全局构造函数，例如，在服务器进程中捕获到 bundle 内部抛出的错误，使用的是 bundle 上下文中的 Error 构造函数，所以它不会是服务器进程中 <code>Error</code> 的一个实例。</li>\n</ol>\n<p>参考：<a href="../guide/structure.md">源码结构</a></p>\n<h3 id="basedir">basedir</h3>\n<ul>\n<li>只用于 <code>createBundleRenderer</code></li>\n</ul>\n<p>显式地声明 server bundle 的运行目录。运行时将会以此目录为基准来解析 <code>node_modules</code> 中的依赖模块。只有在所生成的 bundle 文件与外部的 NPM 依赖模块放置在不同位置，或者 <code>vue-server-renderer</code> 是通过 NPM link 链接到当前项目中时，才需要配置此选项。</p>\n<h3 id="cache">cache</h3>\n<p>提供<a href="../guide/caching.md#component-level-caching">组件缓存</a>具体实现。缓存对象必须实现以下接口（使用 Flow 语法表示）：</p>\n<pre><code class="language-js">type RenderCache = {\n  get: (key: string, cb?: Function) =&gt; string | void;\n  set: (key: string, val: string) =&gt; void;\n  has?: (key: string, cb?: Function) =&gt; boolean | void;\n};</code></pre>\n<p>典型用法是传入 <a href="https://github.com/isaacs/node-lru-cache">lru-cache</a>：</p>\n<pre><code class="language-js">const LRU = require(&#39;lru-cache&#39;)\n\nconst renderer = createRenderer({\n  cache: LRU({\n    max: 10000\n  })\n})</code></pre>\n<p>请注意，缓存对象应至少要实现 <code>get</code> 和 <code>set</code>。此外，如果 <code>get</code> 和 <code>has</code> 接收第二个参数作为回调，那 <code>get</code> 和 <code>has</code> 也可以是可选的异步函数。这允许缓存使用异步 API，例如，一个 Redis 客户端：</p>\n<pre><code class="language-js">const renderer = createRenderer({\n  cache: {\n    get: (key, cb) =&gt; {\n      redisClient.get(key, (err, res) =&gt; {\n        // 处理任何错误\n        cb(res)\n      })\n    },\n    set: (key, val) =&gt; {\n      redisClient.set(key, val)\n    }\n  }\n})</code></pre>\n<h3 id="directives">directives</h3>\n<p>对于自定义指令，允许提供服务器端实现：</p>\n<pre><code class="language-js">const renderer = createRenderer({\n  directives: {\n    example (vnode, directiveMeta) {\n      // 基于指令绑定元数据(metadata)转换 vnode\n    }\n  }\n})</code></pre>\n<p>例如，请查看 <a href="https://github.com/vuejs/vue/blob/dev/src/platforms/web/server/directives/show.js"><code>v-show</code> 的服务器端实现</a>。</p>\n<h2 id="webpack-插件">webpack 插件</h2>\n<p>webpack 插件作为独立文件提供，并且应当直接 require：</p>\n<pre><code class="language-js">const VueSSRServerPlugin = require(&#39;vue-server-renderer/server-plugin&#39;)\nconst VueSSRClientPlugin = require(&#39;vue-server-renderer/client-plugin&#39;)</code></pre>\n<p>生成的默认文件是：</p>\n<ul>\n<li><code>vue-ssr-server-bundle.json</code> 用于服务器端插件；</li>\n<li><code>vue-ssr-client-manifest.json</code> 用于客户端插件。</li>\n</ul>\n<p>创建插件实例时可以自定义文件名：</p>\n<pre><code class="language-js">const plugin = new VueSSRServerPlugin({\n  filename: &#39;my-server-bundle.json&#39;\n})</code></pre>\n<p>更多信息请查看<a href="../guide/build-config.md">构建配置</a>。</p>\n'},162:function(e,n){e.exports='<h1 id="基本用法">基本用法</h1>\n<h2 id="安装">安装</h2>\n<pre><code class="language-bash">npm install vue vue-server-renderer --save</code></pre>\n<p>我们将在整个指南中使用 NPM，但你也可以使用 <a href="https://yarnpkg.com/en/">Yarn</a>。</p>\n<h4 id="注意">注意</h4>\n<ul>\n<li>推荐使用 Node.js 版本 6+。</li>\n<li><code>vue-server-renderer</code> 和 <code>vue</code> 必须匹配版本。</li>\n<li><code>vue-server-renderer</code> 依赖一些 Node.js 原生模块，因此只能在 Node.js 中使用。我们可能会提供一个更简单的构建，可以在将来在其他「JavaScript 运行时(runtime)」运行。</li>\n</ul>\n<h2 id="渲染一个-vue-实例">渲染一个 Vue 实例</h2>\n<pre><code class="language-js">// 第 1 步：创建一个 Vue 实例\nconst Vue = require(&#39;vue&#39;)\nconst app = new Vue({\n  template: `&lt;div&gt;Hello World&lt;/div&gt;`\n})\n\n// 第 2 步：创建一个 renderer\nconst renderer = require(&#39;vue-server-renderer&#39;).createRenderer()\n\n// 第 3 步：将 Vue 实例渲染为 HTML\nrenderer.renderToString(app, (err, html) =&gt; {\n  if (err) throw err\n  console.log(html)\n  // =&gt; &lt;div data-server-rendered=&quot;true&quot;&gt;Hello World&lt;/div&gt;\n})\n\n// 在 2.5.0+，如果没有传入回调函数，则会返回 Promise：\nrenderer.renderToString(app).then(html =&gt; {\n  console.log(html)\n}).catch(err =&gt; {\n  console.error(err)\n})</code></pre>\n<h2 id="与服务器集成">与服务器集成</h2>\n<p>在 Node.js 服务器中使用时相当简单直接，例如 <a href="https://expressjs.com/">Express</a>：</p>\n<pre><code class="language-bash">npm install express --save</code></pre>\n<hr>\n<pre><code class="language-js">const Vue = require(&#39;vue&#39;)\nconst server = require(&#39;express&#39;)()\nconst renderer = require(&#39;vue-server-renderer&#39;).createRenderer()\n\nserver.get(&#39;*&#39;, (req, res) =&gt; {\n  const app = new Vue({\n    data: {\n      url: req.url\n    },\n    template: `&lt;div&gt;访问的 URL 是： {{ url }}&lt;/div&gt;`\n  })\n\n  renderer.renderToString(app, (err, html) =&gt; {\n    if (err) {\n      res.status(500).end(&#39;Internal Server Error&#39;)\n      return\n    }\n    res.end(`\n      &lt;!DOCTYPE html&gt;\n      &lt;html lang=&quot;en&quot;&gt;\n        &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;\n        &lt;body&gt;${html}&lt;/body&gt;\n      &lt;/html&gt;\n    `)\n  })\n})\n\nserver.listen(8080)</code></pre>\n<h2 id="使用一个页面模板">使用一个页面模板</h2>\n<p>当你在渲染 Vue 应用程序时，renderer 只从应用程序生成 HTML 标记 (markup)。在这个示例中，我们必须用一个额外的 HTML 页面包裹容器，来包裹生成的 HTML 标记。</p>\n<p>为了简化这些，你可以直接在创建 renderer 时提供一个页面模板。多数时候，我们会将页面模板放在特有的文件中，例如 <code>index.template.html</code>：</p>\n<pre><code class="language-html">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;\n  &lt;body&gt;\n    &lt;!--vue-ssr-outlet--&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>注意 <code>&lt;!--vue-ssr-outlet--&gt;</code> 注释 -- 这里将是应用程序 HTML 标记注入的地方。</p>\n<p>然后，我们可以读取和传输文件到 Vue renderer 中：</p>\n<pre><code class="language-js">const renderer = createRenderer({\n  template: require(&#39;fs&#39;).readFileSync(&#39;./index.template.html&#39;, &#39;utf-8&#39;)\n})\n\nrenderer.renderToString(app, (err, html) =&gt; {\n  console.log(html) // html 将是注入应用程序内容的完整页面\n})</code></pre>\n<h3 id="模板插值">模板插值</h3>\n<p>模板还支持简单插值。给定如下模板：</p>\n<pre><code class="language-html">&lt;html&gt;\n  &lt;head&gt;\n    &lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt;\n    &lt;title&gt;{{ title }}&lt;/title&gt;\n\n    &lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt;\n    {{{ meta }}}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!--vue-ssr-outlet--&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>我们可以通过传入一个&quot;渲染上下文对象&quot;，作为 <code>renderToString</code> 函数的第二个参数，来提供插值数据：</p>\n<pre><code class="language-js">const context = {\n  title: &#39;hello&#39;,\n  meta: `\n    &lt;meta ...&gt;\n    &lt;meta ...&gt;\n  `\n}\n\nrenderer.renderToString(app, context, (err, html) =&gt; {\n  // 页面 title 将会是 &quot;Hello&quot;\n  // meta 标签也会注入\n})</code></pre>\n<p>也可以与 Vue 应用程序实例共享 <code>context</code> 对象，允许模板插值中的组件动态地注册数据。</p>\n<p>此外，模板支持一些高级特性，例如：</p>\n<ul>\n<li>在使用 <code>*.vue</code> 组件时，自动注入「关键的 CSS(critical CSS)」；</li>\n<li>在使用 <code>clientManifest</code> 时，自动注入「资源链接(asset links)和资源预加载提示(resource hints)」；</li>\n<li>在嵌入 Vuex 状态进行客户端融合(client-side hydration)时，自动注入以及 XSS 防御。</li>\n</ul>\n<p>在之后的指南中介绍相关概念时，我们将详细讨论这些。</p>\n'},163:function(e,n){e.exports='<h1 id="构建配置">构建配置</h1>\n<p>我们假设你已经知道，如何为纯客户端 (client-only) 项目配置 webpack。服务器端渲染 (SSR) 项目的配置大体上与纯客户端项目类似，但是我们建议将配置分为三个文件：<em>base</em>, <em>client</em> 和 <em>server</em>。基本配置 (base config) 包含在两个环境共享的配置，例如，输出路径 (output path)，别名 (alias) 和 loader。服务器配置 (server config) 和客户端配置 (client config)，可以通过使用 <a href="https://github.com/survivejs/webpack-merge">webpack-merge</a> 来简单地扩展基本配置。</p>\n<h2 id="服务器配置-server-config">服务器配置 (Server Config)</h2>\n<p>服务器配置，是用于生成传递给 <code>createBundleRenderer</code> 的 server bundle。它应该是这样的：</p>\n<pre><code class="language-js">const merge = require(&#39;webpack-merge&#39;)\nconst nodeExternals = require(&#39;webpack-node-externals&#39;)\nconst baseConfig = require(&#39;./webpack.base.config.js&#39;)\nconst VueSSRServerPlugin = require(&#39;vue-server-renderer/server-plugin&#39;)\n\nmodule.exports = merge(baseConfig, {\n  // 将 entry 指向应用程序的 server entry 文件\n  entry: &#39;/path/to/entry-server.js&#39;,\n\n  // 这允许 webpack 以 Node 适用方式(Node-appropriate fashion)处理动态导入(dynamic import)，\n  // 并且还会在编译 Vue 组件时，\n  // 告知 `vue-loader` 输送面向服务器代码(server-oriented code)。\n  target: &#39;node&#39;,\n\n  // 对 bundle renderer 提供 source map 支持\n  devtool: &#39;source-map&#39;,\n\n  // 此处告知 server bundle 使用 Node 风格导出模块(Node-style exports)\n  output: {\n    libraryTarget: &#39;commonjs2&#39;\n  },\n\n  // https://webpack.js.org/configuration/externals/#function\n  // https://github.com/liady/webpack-node-externals\n  // 外置化应用程序依赖模块。可以使服务器构建速度更快，\n  // 并生成较小的 bundle 文件。\n  externals: nodeExternals({\n    // 不要外置化 webpack 需要处理的依赖模块。\n    // 你可以在这里添加更多的文件类型。例如，未处理 *.vue 原始文件，\n    // 你还应该将修改 `global`（例如 polyfill）的依赖模块列入白名单\n    whitelist: /\\.css$/\n  }),\n\n  // 这是将服务器的整个输出\n  // 构建为单个 JSON 文件的插件。\n  // 默认文件名为 `vue-ssr-server-bundle.json`\n  plugins: [\n    new VueSSRServerPlugin()\n  ]\n})</code></pre>\n<p>在生成 <code>vue-ssr-server-bundle.json</code> 之后，只需将文件路径传递给 <code>createBundleRenderer</code>：</p>\n<pre><code class="language-js">const { createBundleRenderer } = require(&#39;vue-server-renderer&#39;)\nconst renderer = createBundleRenderer(&#39;/path/to/vue-ssr-server-bundle.json&#39;, {\n  // ……renderer 的其他选项\n})</code></pre>\n<p>又或者，你还可以将 bundle 作为对象传递给 <code>createBundleRenderer</code>。这对开发过程中的热重载是很有用的 - 具体请查看 HackerNews demo 的<a href="https://github.com/vuejs/vue-hackernews-2.0/blob/master/build/setup-dev-server.js">参考设置</a>。</p>\n<h3 id="扩展说明-externals-caveats">扩展说明 (Externals Caveats)</h3>\n<p>请注意，在 <code>externals</code> 选项中，我们将 CSS 文件列入白名单。这是因为从依赖模块导入的 CSS 还应该由 webpack 处理。如果你导入依赖于 webpack 的任何其他类型的文件（例如 <code>*.vue</code>, <code>*.sass</code>），那么你也应该将它们添加到白名单中。</p>\n<p>如果你使用 <code>runInNewContext: &#39;once&#39;</code> 或 <code>runInNewContext: true</code>，那么你还应该将修改 <code>global</code> 的 polyfill 列入白名单，例如 <code>babel-polyfill</code>。这是因为当使用新的上下文模式时，<strong>server bundle 中的代码具有自己的 <code>global</code> 对象。</strong>由于在使用 Node 7.6+ 时，在服务器并不真正需要它，所以实际上只需在客户端 entry 导入它。</p>\n<h2 id="客户端配置-client-config">客户端配置 (Client Config)</h2>\n<p>客户端配置 (client config) 和基本配置 (base config) 大体上相同。显然你需要把 <code>entry</code> 指向你的客户端入口文件。除此之外，如果你使用 <code>CommonsChunkPlugin</code>，请确保仅在客户端配置 (client config) 中使用，因为服务器包需要单独的入口 chunk。</p>\n<h3 id="生成-clientmanifest">生成 <code>clientManifest</code></h3>\n<blockquote>\n<p>需要版本 2.3.0+</p>\n</blockquote>\n<p>除了 server bundle 之外，我们还可以生成客户端构建清单 (client build manifest)。使用客户端清单 (client manifest) 和服务器 bundle(server bundle)，renderer 现在具有了<em>服务器和客户端</em>的构建信息，因此它可以自动推断和注入<a href="https://css-tricks.com/prefetching-preloading-prebrowsing/">资源预加载 / 数据预取指令(preload / prefetch directive)</a>，以及 css 链接 / script 标签到所渲染的 HTML。</p>\n<p>好处是双重的：</p>\n<ol>\n<li><p>在生成的文件名中有哈希时，可以取代 <code>html-webpack-plugin</code> 来注入正确的资源 URL。</p>\n</li>\n<li><p>在通过 webpack 的按需代码分割特性渲染 bundle 时，我们可以确保对 chunk 进行最优化的资源预加载/数据预取，并且还可以将所需的异步 chunk 智能地注入为 <code>&lt;script&gt;</code> 标签，以避免客户端的瀑布式请求 (waterfall request)，以及改善可交互时间 (TTI - time-to-interactive)。</p>\n</li>\n</ol>\n<p>要使用客户端清单 (client manifest)，客户端配置 (client config) 将如下所示：</p>\n<pre><code class="language-js">const webpack = require(&#39;webpack&#39;)\nconst merge = require(&#39;webpack-merge&#39;)\nconst baseConfig = require(&#39;./webpack.base.config.js&#39;)\nconst VueSSRClientPlugin = require(&#39;vue-server-renderer/client-plugin&#39;)\n\nmodule.exports = merge(baseConfig, {\n  entry: &#39;/path/to/entry-client.js&#39;,\n  plugins: [\n    // 重要信息：这将 webpack 运行时分离到一个引导 chunk 中，\n    // 以便可以在之后正确注入异步 chunk。\n    // 这也为你的 应用程序/vendor 代码提供了更好的缓存。\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &quot;manifest&quot;,\n      minChunks: Infinity\n    }),\n    // 此插件在输出目录中\n    // 生成 `vue-ssr-client-manifest.json`。\n    new VueSSRClientPlugin()\n  ]\n})</code></pre>\n<p>然后，你就可以使用生成的客户端清单 (client manifest) 以及页面模板：</p>\n<pre><code class="language-js">const { createBundleRenderer } = require(&#39;vue-server-renderer&#39;)\n\nconst template = require(&#39;fs&#39;).readFileSync(&#39;/path/to/template.html&#39;, &#39;utf-8&#39;)\nconst serverBundle = require(&#39;/path/to/vue-ssr-server-bundle.json&#39;)\nconst clientManifest = require(&#39;/path/to/vue-ssr-client-manifest.json&#39;)\n\nconst renderer = createBundleRenderer(serverBundle, {\n  template,\n  clientManifest\n})</code></pre>\n<p>通过以上设置，使用代码分割特性构建后的服务器渲染的 HTML 代码，将看起来如下（所有都是自动注入）：</p>\n<pre><code class="language-html">&lt;html&gt;\n  &lt;head&gt;\n    &lt;!-- 用于当前渲染的 chunk 会被资源预加载(preload) --&gt;\n    &lt;link rel=&quot;preload&quot; href=&quot;/manifest.js&quot; as=&quot;script&quot;&gt;\n    &lt;link rel=&quot;preload&quot; href=&quot;/main.js&quot; as=&quot;script&quot;&gt;\n    &lt;link rel=&quot;preload&quot; href=&quot;/0.js&quot; as=&quot;script&quot;&gt;\n    &lt;!-- 未用到的异步 chunk 会被数据预取(prefetch)（次要优先级） --&gt;\n    &lt;link rel=&quot;prefetch&quot; href=&quot;/1.js&quot; as=&quot;script&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 应用程序内容 --&gt;\n    &lt;div data-server-rendered=&quot;true&quot;&gt;&lt;div&gt;async&lt;/div&gt;&lt;/div&gt;\n    &lt;!-- manifest chunk 优先 --&gt;\n    &lt;script src=&quot;/manifest.js&quot;&gt;&lt;/script&gt;\n    &lt;!-- 在主 chunk 之前注入异步 chunk --&gt;\n    &lt;script src=&quot;/0.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;/main.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<h3 id="手动资源注入manual-asset-injection">手动资源注入(Manual Asset Injection)</h3>\n<p>默认情况下，当提供 <code>template</code> 渲染选项时，资源注入是自动执行的。但是有时候，你可能需要对资源注入的模板进行更细粒度 (finer-grained) 的控制，或者你根本不使用模板。在这种情况下，你可以在创建 renderer 并手动执行资源注入时，传入 <code>inject: false</code>。</p>\n<p>在 <code>renderToString</code> 回调函数中，你传入的 <code>context</code> 对象会暴露以下方法：</p>\n<ul>\n<li><p><code>context.renderStyles()</code></p>\n<p>这将返回内联 <code>&lt;style&gt;</code> 标签包含所有关键 CSS(critical CSS) ，其中关键 CSS 是在要用到的 <code>*.vue</code> 组件的渲染过程中收集的。有关更多详细信息，请查看 <a href="./css.md">CSS 管理</a>。</p>\n<p>如果提供了 <code>clientManifest</code>，返回的字符串中，也将包含着 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 标签内由 webpack 输出(webpack-emitted)的 CSS 文件（例如，使用 <code>extract-text-webpack-plugin</code> 提取的 CSS，或使用 <code>file-loader</code> 导入的 CSS）</p>\n</li>\n<li><p><code>context.renderState(options?: Object)</code></p>\n<p>此方法序列化 <code>context.state</code> 并返回一个内联的 script，其中状态被嵌入在 <code>window.__INITIAL_STATE__</code> 中。</p>\n<p>上下文状态键 (context state key) 和 window 状态键 (window state key)，都可以通过传递选项对象进行自定义：</p>\n<pre><code class="language-js">context.renderState({\n  contextKey: &#39;myCustomState&#39;,\n  windowKey: &#39;__MY_STATE__&#39;\n})\n\n// -&gt; &lt;script&gt;window.__MY_STATE__={...}&lt;/script&gt;</code></pre>\n</li>\n<li><p><code>context.renderScripts()</code></p>\n<ul>\n<li>需要 <code>clientManifest</code></li>\n</ul>\n<p>此方法返回引导客户端应用程序所需的 <code>&lt;script&gt;</code> 标签。当在应用程序代码中使用异步代码分割 (async code-splitting) 时，此方法将智能地正确的推断需要引入的那些异步 chunk。</p>\n</li>\n<li><p><code>context.renderResourceHints()</code></p>\n<ul>\n<li>需要 <code>clientManifest</code></li>\n</ul>\n<p>此方法返回当前要渲染的页面，所需的 <code>&lt;link rel=&quot;preload/prefetch&quot;&gt;</code> 资源提示 (resource hint)。默认情况下会：</p>\n<ul>\n<li>预加载页面所需的 JavaScript 和 CSS 文件</li>\n<li>预取异步 JavaScript chunk，之后可能会用于渲染</li>\n</ul>\n<p>使用 <a href="../api/#shouldpreload"><code>shouldPreload</code></a> 选项可以进一步自定义要预加载的文件。</p>\n</li>\n<li><p><code>context.getPreloadFiles()</code></p>\n<ul>\n<li>需要 <code>clientManifest</code></li>\n</ul>\n<p>此方法不返回字符串 - 相反，它返回一个数组，此数组是由要预加载的资源文件对象所组成。这可以用在以编程方式 (programmatically) 执行 HTTP/2 服务器推送 (HTTP/2 server push)。</p>\n</li>\n</ul>\n<p>由于传递给 <code>createBundleRenderer</code> 的 <code>template</code> 将会使用 <code>context</code> 对象进行插值，你可以（通过传入 <code>inject: false</code>）在模板中使用这些方法：</p>\n<pre><code class="language-html">&lt;html&gt;\n  &lt;head&gt;\n    &lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt;\n    {{{ renderResourceHints() }}}\n    {{{ renderStyles() }}}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!--vue-ssr-outlet--&gt;\n    {{{ renderState() }}}\n    {{{ renderScripts() }}}\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>如果你根本没有使用 <code>template</code>，你可以自己拼接字符串。</p>\n'},164:function(e,n){e.exports='<h1 id="bundle-renderer-指引">Bundle Renderer 指引</h1>\n<h2 id="使用基本-ssr-的问题">使用基本 SSR 的问题</h2>\n<p>到目前为止，我们假设打包的服务器端代码，将由服务器通过 <code>require</code> 直接使用：</p>\n<pre><code class="language-js">const createApp = require(&#39;/path/to/built-server-bundle.js&#39;)</code></pre>\n<p>这是理所应当的，然而在每次编辑过应用程序源代码之后，都必须停止并重启服务。这在开发过程中会影响开发效率。此外，Node.js 本身不支持 source map。</p>\n<h2 id="传入-bundlerenderer">传入 BundleRenderer</h2>\n<p><code>vue-server-renderer</code> 提供一个名为 <code>createBundleRenderer</code> 的 API，用于处理此问题，通过使用 webpack 的自定义插件，server bundle 将生成为可传递到 bundle renderer 的特殊 JSON 文件。所创建的 bundle renderer，用法和普通 renderer 相同，但是 bundle renderer 提供以下优点：</p>\n<ul>\n<li><p>内置的 source map 支持（在 webpack 配置中使用 <code>devtool: &#39;source-map&#39;</code>）</p>\n</li>\n<li><p>在开发环境甚至部署过程中热重载（通过读取更新后的 bundle，然后重新创建 renderer 实例）</p>\n</li>\n<li><p>关键 CSS(critical CSS) 注入（在使用 <code>*.vue</code> 文件时）：自动内联在渲染过程中用到的组件所需的CSS。更多细节请查看 <a href="./css.md">CSS</a> 章节。</p>\n</li>\n<li><p>使用 <a href="../api/#clientmanifest">clientManifest</a> 进行资源注入：自动推断出最佳的预加载(preload)和预取(prefetch)指令，以及初始渲染所需的代码分割 chunk。</p>\n</li>\n</ul>\n<hr>\n<p>在下一章节中，我们将讨论如何配置 webpack，以生成 bundle renderer 所需的构建工件 (build artifact)，但现在假设我们已经有了这些需要的构建工件，以下就是创建和使用 bundle renderer 的方法：</p>\n<pre><code class="language-js">const { createBundleRenderer } = require(&#39;vue-server-renderer&#39;)\n\nconst renderer = createBundleRenderer(serverBundle, {\n  runInNewContext: false, // 推荐\n  template, // （可选）页面模板\n  clientManifest // （可选）客户端构建 manifest\n})\n\n// 在服务器处理函数中……\nserver.get(&#39;*&#39;, (req, res) =&gt; {\n  const context = { url: req.url }\n  // 这里无需传入一个应用程序，因为在执行 bundle 时已经自动创建过。\n  // 现在我们的服务器与应用程序已经解耦！\n  renderer.renderToString(context, (err, html) =&gt; {\n    // 处理异常……\n    res.end(html)\n  })\n})</code></pre>\n<p>bundle renderer 在调用 <code>renderToString</code> 时，它将自动执行「由 bundle 创建的应用程序实例」所导出的函数（传入<code>上下文</code>作为参数），然后渲染它。</p>\n<p>注意，推荐将 <code>runInNewContext</code> 选项设置为 <code>false</code> 或 <code>&#39;once&#39;</code>。更多细节请查看 <a href="../api/#runinnewcontext">API 参考</a>。</p>\n'},165:function(e,n){e.exports='<h1 id="缓存">缓存</h1>\n<p>虽然 Vue 的服务器端渲染 (SSR) 相当快速，但是由于创建组件实例和虚拟 DOM 节点的开销，无法与纯基于字符串拼接 (pure string-based) 的模板的性能相当。在 SSR 性能至关重要的情况下，明智地利用缓存策略，可以极大改善响应时间并减少服务器负载。</p>\n<h2 id="页面级别缓存-page-level-caching">页面级别缓存 (Page-level Caching)</h2>\n<p>在大多数情况下，服务器渲染的应用程序依赖于外部数据，因此本质上页面内容是动态的，不能持续长时间缓存。然而，如果内容不是用户特定 (user-specific)（即对于相同的 URL，总是为所有用户渲染相同的内容），我们可以利用名为 <a href="https://www.nginx.com/blog/benefits-of-microcaching-nginx/">micro-caching</a> 的缓存策略，来大幅度提高应用程序处理高流量的能力。</p>\n<p>这通常在 Nginx 层完成，但是我们也可以在 Node.js 中实现它：</p>\n<pre><code class="language-js">const microCache = LRU({\n  max: 100,\n  maxAge: 1000 // 重要提示：条目在 1 秒后过期。\n})\n\nconst isCacheable = req =&gt; {\n  // 实现逻辑为，检查请求是否是用户特定(user-specific)。\n  // 只有非用户特定 (non-user-specific) 页面才会缓存\n}\n\nserver.get(&#39;*&#39;, (req, res) =&gt; {\n  const cacheable = isCacheable(req)\n  if (cacheable) {\n    const hit = microCache.get(req.url)\n    if (hit) {\n      return res.end(hit)\n    }\n  }\n\n  renderer.renderToString((err, html) =&gt; {\n    res.end(html)\n    if (cacheable) {\n      microCache.set(req.url, html)\n    }\n  })\n})</code></pre>\n<p>由于内容缓存只有一秒钟，用户将无法查看过期的内容。然而，这意味着，对于每个要缓存的页面，服务器最多只能每秒执行一次完整渲染。</p>\n<h2 id="组件级别缓存-component-level-caching">组件级别缓存 (Component-level Caching)</h2>\n<p><code>vue-server-renderer</code> 内置支持组件级别缓存 (component-level caching)。要启用组件级别缓存，你需要在创建 renderer 时提供<a href="../api/#cache">具体缓存实现方式(cache implementation)</a>。典型做法是传入 <a href="https://github.com/isaacs/node-lru-cache">lru-cache</a>：</p>\n<pre><code class="language-js">const LRU = require(&#39;lru-cache&#39;)\n\nconst renderer = createRenderer({\n  cache: LRU({\n    max: 10000,\n    maxAge: ...\n  })\n})</code></pre>\n<p>然后，你可以通过实现 <code>serverCacheKey</code> 函数来缓存组件。</p>\n<pre><code class="language-js">export default {\n  name: &#39;item&#39;, // 必填选项\n  props: [&#39;item&#39;],\n  serverCacheKey: props =&gt; props.item.id,\n  render (h) {\n    return h(&#39;div&#39;, this.item.id)\n  }\n}</code></pre>\n<p>请注意，可缓存组件<strong>还必须定义一个唯一的 <code>name</code> 选项</strong>。通过使用唯一的名称，每个缓存键 (cache key) 对应一个组件：你无需担心两个组件返回同一个 key。</p>\n<p><code>serverCacheKey</code> 返回的 key 应该包含足够的信息，来表示渲染结果的具体情况。如果渲染结果仅由 <code>props.item.id</code> 决定，则上述是一个很好的实现。但是，如果具有相同 id 的 item 可能会随时间而变化，或者如果渲染结果依赖于其他 prop，则需要修改 <code>serverCacheKey</code> 的实现，以考虑其他变量。</p>\n<p>返回常量将导致组件始终被缓存，这对纯静态组件是有好处的。</p>\n<h3 id="何时使用组件缓存">何时使用组件缓存</h3>\n<p>如果 renderer 在组件渲染过程中进行缓存命中，那么它将直接重新使用整个子树的缓存结果。这意味着在以下情况，你<strong>不</strong>应该缓存组件：</p>\n<ul>\n<li>它具有可能依赖于全局状态的子组件。</li>\n<li>它具有对渲染<code>上下文</code>产生副作用(side effect)的子组件。</li>\n</ul>\n<p>因此，应该小心使用组件缓存来解决性能瓶颈。在大多数情况下，你不应该也不需要缓存单一实例组件。适用于缓存的最常见类型的组件，是在大的 <code>v-for</code> 列表中重复出现的组件。由于这些组件通常由数据库集合(database collection)中的对象驱动，它们可以使用简单的缓存策略：使用其唯一 id，再加上最后更新的时间戳，来生成其缓存键(cache key)：</p>\n<pre><code class="language-js">serverCacheKey: props =&gt; props.item.id + &#39;::&#39; + props.item.last_updated</code></pre>\n'},166:function(e,n){e.exports='<h1 id="css-管理">CSS 管理</h1>\n<p>管理 CSS 的推荐方法是简单地使用 <code>*.vue</code> 单个文件组件内的 <code>&lt;style&gt;</code>，它提供：</p>\n<ul>\n<li>与 HTML 并列同级，组件作用域 CSS</li>\n<li>能够使用预处理器(pre-processor)或 PostCSS</li>\n<li>开发过程中热重载(hot-reload)</li>\n</ul>\n<p>更重要的是，<code>vue-style-loader</code>（<code>vue-loader</code> 内部使用的 loader），具备一些服务器端渲染的特殊功能：</p>\n<ul>\n<li><p>客户端和服务器端的通用编程体验。</p>\n</li>\n<li><p>在使用 <code>bundleRenderer</code> 时，自动注入关键 CSS(critical CSS)。</p>\n<p>如果在服务器端渲染期间使用，可以在 HTML 中收集和内联（使用 <code>template</code> 选项时自动处理）组件的 CSS。在客户端，当第一次使用该组件时，<code>vue-style-loader</code> 会检查这个组件是否已经具有服务器内联(server-inlined)的 CSS - 如果没有，CSS 将通过 <code>&lt;style&gt;</code> 标签动态注入。</p>\n</li>\n<li><p>通用 CSS 提取。</p>\n<p>此设置支持使用 <a href="https://github.com/webpack-contrib/extract-text-webpack-plugin"><code>extract-text-webpack-plugin</code></a> 将主 chunk(main chunk) 中的 CSS 提取到单独的 CSS 文件中（使用 <code>template</code> 自动注入），这样可以将文件分开缓存。建议用于存在很多公用 CSS 时。</p>\n<p>内部异步组件中的 CSS 将内联为 JavaScript 字符串，并由 <code>vue-style-loader</code> 处理。</p>\n</li>\n</ul>\n<h2 id="启用-css-提取">启用 CSS 提取</h2>\n<p>要从 <code>*.vue</code> 文件中提取 CSS，可以使用 <code>vue-loader</code> 的 <code>extractCSS</code> 选项（需要 <code>vue-loader</code> 12.0.0+）</p>\n<pre><code class="language-js">// webpack.config.js\nconst ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)\n\n// CSS 提取应该只用于生产环境\n// 这样我们在开发过程中仍然可以热重载\nconst isProduction = process.env.NODE_ENV === &#39;production&#39;\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: &#39;vue-loader&#39;,\n        options: {\n          // enable CSS extraction\n          extractCSS: isProduction\n        }\n      },\n      // ...\n    ]\n  },\n  plugins: isProduction\n    // 确保添加了此插件！\n    ? [new ExtractTextPlugin({ filename: &#39;common.[chunkhash].css&#39; })]\n    : []\n}</code></pre>\n<p>请注意，上述配置仅适用于 <code>*.vue</code> 文件中的样式，然而你也可以使用 <code>&lt;style src=&quot;./foo.css&quot;&gt;</code> 将外部 CSS 导入 Vue 组件。</p>\n<p>如果你想从 JavaScript 中导入 CSS，例如，<code>import &#39;foo.css&#39;</code>，你需要配置合适的 loader：</p>\n<pre><code class="language-js">module.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // 重要：使用 vue-style-loader 替代 style-loader\n        use: isProduction\n          ? ExtractTextPlugin.extract({\n              use: &#39;css-loader&#39;,\n              fallback: &#39;vue-style-loader&#39;\n            })\n          : [&#39;vue-style-loader&#39;, &#39;css-loader&#39;]\n      }\n    ]\n  },\n  // ...\n}</code></pre>\n<h2 id="从依赖模块导入样式">从依赖模块导入样式</h2>\n<p>从 NPM 依赖模块导入 CSS 时需要注意的几点：</p>\n<ol>\n<li><p>在服务器端构建过程中，不应该外置化提取。</p>\n</li>\n<li><p>在使用 CSS 提取 + 使用 <code>CommonsChunkPlugin</code> 插件提取 vendor 时，如果提取的 CSS 位于提取的 vendor chunk 之中，<code>extract-text-webpack-plugin</code> 会遇到问题。为了解决这个问题，请避免在 vendor chunk 中包含 CSS 文件。客户端 webpack 配置示例如下：</p>\n<pre><code class="language-js">module.exports = {\n // ...\n plugins: [\n   // 将依赖模块提取到 vendor chunk 以获得更好的缓存，是很常见的做法。\n   new webpack.optimize.CommonsChunkPlugin({\n     name: &#39;vendor&#39;,\n     minChunks: function (module) {\n       // 一个模块被提取到 vendor chunk 时……\n       return (\n         // 如果它在 node_modules 中\n         /node_modules/.test(module.context) &amp;&amp;\n         // 如果 request 是一个 CSS 文件，则无需外置化提取\n         !/\\.css$/.test(module.request)\n       )\n     }\n   }),\n   // 提取 webpack 运行时和 manifest\n   new webpack.optimize.CommonsChunkPlugin({\n     name: &#39;manifest&#39;\n   }),\n   // ...\n ]\n}</code></pre>\n</li>\n</ol>\n'},167:function(e,n){e.exports='<h1 id="数据预取和状态">数据预取和状态</h1>\n<h2 id="数据预取存储容器-data-store">数据预取存储容器 (Data Store)</h2>\n<p>在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的&quot;快照&quot;，所以如果应用程序依赖于一些异步数据，<strong>那么在开始渲染过程之前，需要先预取和解析好这些数据</strong>。</p>\n<p>另一个需要关注的问题是在客户端，在挂载 (mount) 到客户端应用程序之前，需要获取到与服务器端应用程序完全相同的数据 - 否则，客户端应用程序会因为使用与服务器端应用程序不同的状态，然后导致混合失败。</p>\n<p>为了解决这个问题，获取的数据需要位于视图组件之外，即放置在专门的数据预取存储容器(data store)或&quot;状态容器(state container)）&quot;中。首先，在服务器端，我们可以在渲染之前预取数据，并将数据填充到 store 中。此外，我们将在 HTML 中序列化(serialize)和内联预置(inline)状态。这样，在挂载(mount)到客户端应用程序之前，可以直接从 store 获取到内联预置(inline)状态。</p>\n<p>为此，我们将使用官方状态管理库 <a href="https://github.com/vuejs/vuex/">Vuex</a>。我们先创建一个 <code>store.js</code> 文件，里面会模拟一些根据 id 获取 item 的逻辑：</p>\n<pre><code class="language-js">// store.js\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n\nVue.use(Vuex)\n\n// 假定我们有一个可以返回 Promise 的\n// 通用 API（请忽略此 API 具体实现细节）\nimport { fetchItem } from &#39;./api&#39;\n\nexport function createStore () {\n  return new Vuex.Store({\n    state: {\n      items: {}\n    },\n    actions: {\n      fetchItem ({ commit }, id) {\n        // `store.dispatch()` 会返回 Promise，\n        // 以便我们能够知道数据在何时更新\n        return fetchItem(id).then(item =&gt; {\n          commit(&#39;setItem&#39;, { id, item })\n        })\n      }\n    },\n    mutations: {\n      setItem (state, { id, item }) {\n        Vue.set(state.items, id, item)\n      }\n    }\n  })\n}</code></pre>\n<p>然后修改 <code>app.js</code>：</p>\n<pre><code class="language-js">// app.js\nimport Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport { createRouter } from &#39;./router&#39;\nimport { createStore } from &#39;./store&#39;\nimport { sync } from &#39;vuex-router-sync&#39;\n\nexport function createApp () {\n  // 创建 router 和 store 实例\n  const router = createRouter()\n  const store = createStore()\n\n  // 同步路由状态(route state)到 store\n  sync(store, router)\n\n  // 创建应用程序实例，将 router 和 store 注入\n  const app = new Vue({\n    router,\n    store,\n    render: h =&gt; h(App)\n  })\n\n  // 暴露 app, router 和 store。\n  return { app, router, store }\n}</code></pre>\n<h2 id="带有逻辑配置的组件-logic-collocation-with-components">带有逻辑配置的组件 (Logic Collocation with Components)</h2>\n<p>那么，我们在哪里放置「dispatch 数据预取 action」的代码？</p>\n<p>我们需要通过访问路由，来决定获取哪部分数据 - 这也决定了哪些组件需要渲染。事实上，给定路由所需的数据，也是在该路由上渲染组件时所需的数据。所以在路由组件中放置数据预取逻辑，是很自然的事情。</p>\n<p>我们将在路由组件上暴露出一个自定义静态函数 <code>asyncData</code>。注意，由于此函数会在组件实例化之前调用，所以它无法访问 <code>this</code>。需要将 store 和路由信息作为参数传递进去：</p>\n<pre><code class="language-html">&lt;!-- Item.vue --&gt;\n&lt;template&gt;\n  &lt;div&gt;{{ item.title }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  asyncData ({ store, route }) {\n    // 触发 action 后，会返回 Promise\n    return store.dispatch(&#39;fetchItem&#39;, route.params.id)\n  },\n  computed: {\n    // 从 store 的 state 对象中的获取 item。\n    item () {\n      return this.$store.state.items[this.$route.params.id]\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<h2 id="服务器端数据预取-server-data-fetching">服务器端数据预取 (Server Data Fetching)</h2>\n<p>在 <code>entry-server.js</code> 中，我们可以通过路由获得与 <code>router.getMatchedComponents()</code> 相匹配的组件，如果组件暴露出 <code>asyncData</code>，我们就调用这个方法。然后我们需要将解析完成的状态，附加到渲染上下文(render context)中。</p>\n<pre><code class="language-js">// entry-server.js\nimport { createApp } from &#39;./app&#39;\n\nexport default context =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    const { app, router, store } = createApp()\n\n    router.push(context.url)\n\n    router.onReady(() =&gt; {\n      const matchedComponents = router.getMatchedComponents()\n      if (!matchedComponents.length) {\n        return reject({ code: 404 })\n      }\n\n      // 对所有匹配的路由组件调用 `asyncData()`\n      Promise.all(matchedComponents.map(Component =&gt; {\n        if (Component.asyncData) {\n          return Component.asyncData({\n            store,\n            route: router.currentRoute\n          })\n        }\n      })).then(() =&gt; {\n        // 在所有预取钩子(preFetch hook) resolve 后，\n        // 我们的 store 现在已经填充入渲染应用程序所需的状态。\n        // 当我们将状态附加到上下文，\n        // 并且 `template` 选项用于 renderer 时，\n        // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。\n        context.state = store.state\n\n        resolve(app)\n      }).catch(reject)\n    }, reject)\n  })\n}</code></pre>\n<p>当使用 <code>template</code> 时，<code>context.state</code> 将作为 <code>window.__INITIAL_STATE__</code> 状态，自动嵌入到最终的 HTML 中。而在客户端，在挂载到应用程序之前，store 就应该获取到状态：</p>\n<pre><code class="language-js">// entry-client.js\n\nconst { app, router, store } = createApp()\n\nif (window.__INITIAL_STATE__) {\n  store.replaceState(window.__INITIAL_STATE__)\n}</code></pre>\n<h2 id="客户端数据预取-client-data-fetching">客户端数据预取 (Client Data Fetching)</h2>\n<p>在客户端，处理数据预取有两种不同方式：</p>\n<ol>\n<li><p><strong>在路由导航之前解析数据：</strong></p>\n<p>使用此策略，应用程序会等待视图所需数据全部解析之后，再传入数据并处理当前视图。好处在于，可以直接在数据准备就绪时，传入视图渲染完整内容，但是如果数据预取需要很长时间，用户在当前视图会感受到&quot;明显卡顿&quot;。因此，如果使用此策略，建议提供一个数据加载指示器 (data loading indicator)。</p>\n<p>我们可以通过检查匹配的组件，并在全局路由钩子函数中执行 <code>asyncData</code> 函数，来在客户端实现此策略。注意，在初始路由准备就绪之后，我们应该注册此钩子，这样我们就不必再次获取服务器提取的数据。</p>\n<pre><code class="language-js">// entry-client.js\n\n// ...忽略无关代码\n\nrouter.onReady(() =&gt; {\n // 添加路由钩子函数，用于处理 asyncData.\n // 在初始路由 resolve 后执行，\n // 以便我们不会二次预取(double-fetch)已有的数据。\n // 使用 `router.beforeResolve()`，以便确保所有异步组件都 resolve。\n router.beforeResolve((to, from, next) =&gt; {\n   const matched = router.getMatchedComponents(to)\n   const prevMatched = router.getMatchedComponents(from)\n\n   // 我们只关心非预渲染的组件\n   // 所以我们对比它们，找出两个匹配列表的差异组件\n   let diffed = false\n   const activated = matched.filter((c, i) =&gt; {\n     return diffed || (diffed = (prevMatched[i] !== c))\n   })\n\n   if (!activated.length) {\n     return next()\n   }\n\n   // 这里如果有加载指示器 (loading indicator)，就触发\n\n   Promise.all(activated.map(c =&gt; {\n     if (c.asyncData) {\n       return c.asyncData({ store, route: to })\n     }\n   })).then(() =&gt; {\n\n     // 停止加载指示器(loading indicator)\n\n     next()\n   }).catch(next)\n })\n\n app.$mount(&#39;#app&#39;)\n})</code></pre>\n</li>\n<li><p><strong>匹配要渲染的视图后，再获取数据：</strong></p>\n<p>此策略将客户端数据预取逻辑，放在视图组件的 <code>beforeMount</code> 函数中。当路由导航被触发时，可以立即切换视图，因此应用程序具有更快的响应速度。然而，传入视图在渲染时不会有完整的可用数据。因此，对于使用此策略的每个视图组件，都需要具有条件加载状态。</p>\n<p>这可以通过纯客户端 (client-only) 的全局 mixin 来实现：</p>\n<pre><code class="language-js">Vue.mixin({\n beforeMount () {\n   const { asyncData } = this.$options\n   if (asyncData) {\n     // 将获取数据操作分配给 promise\n     // 以便在组件中，我们可以在数据准备就绪后\n     // 通过运行 `this.dataPromise.then(...)` 来执行其他任务\n     this.dataPromise = asyncData({\n       store: this.$store,\n       route: this.$route\n     })\n   }\n }\n})</code></pre>\n</li>\n</ol>\n<p>这两种策略是根本上不同的用户体验决策，应该根据你创建的应用程序的实际使用场景进行挑选。但是无论你选择哪种策略，当路由组件重用（同一路由，但是 params 或 query 已更改，例如，从 <code>user/1</code> 到 <code>user/2</code>）时，也应该调用 <code>asyncData</code> 函数。我们也可以通过纯客户端 (client-only) 的全局 mixin 来处理这个问题：</p>\n<pre><code class="language-js">Vue.mixin({\n  beforeRouteUpdate (to, from, next) {\n    const { asyncData } = this.$options\n    if (asyncData) {\n      asyncData({\n        store: this.$store,\n        route: to\n      }).then(next).catch(next)\n    } else {\n      next()\n    }\n  }\n})</code></pre>\n<h2 id="store-代码拆分-store-code-splitting">Store 代码拆分 (Store Code Splitting)</h2>\n<p>在大型应用程序中，我们的 Vuex store 可能会分为多个模块。当然，也可以将这些模块代码，分割到相应的路由组件 chunk 中。假设我们有以下 store 模块：</p>\n<pre><code class="language-js">// store/modules/foo.js\nexport default {\n  namespaced: true,\n  // 重要信息：state 必须是一个函数，\n  // 因此可以创建多个实例化该模块\n  state: () =&gt; ({\n    count: 0\n  }),\n  actions: {\n    inc: ({ commit }) =&gt; commit(&#39;inc&#39;)\n  },\n  mutations: {\n    inc: state =&gt; state.count++\n  }\n}</code></pre>\n<p>我们可以在路由组件的 <code>asyncData</code> 钩子函数中，使用 <code>store.registerModule</code> 惰性注册(lazy-register)这个模块：</p>\n<pre><code class="language-html">// 在路由组件内\n&lt;template&gt;\n  &lt;div&gt;{{ fooCount }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// 在这里导入模块，而不是在 `store/index.js` 中\nimport fooStoreModule from &#39;../store/modules/foo&#39;\n\nexport default {\n  asyncData ({ store }) {\n    store.registerModule(&#39;foo&#39;, fooStoreModule)\n    return store.dispatch(&#39;foo/inc&#39;)\n  },\n\n  // 重要信息：当多次访问路由时，\n  // 避免在客户端重复注册模块。\n  destroyed () {\n    this.$store.unregisterModule(&#39;foo&#39;)\n  },\n\n  computed: {\n    fooCount () {\n      return this.$store.state.foo.count\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>由于模块现在是路由组件的依赖，所以它将被 webpack 移动到路由组件的异步 chunk 中。</p>\n<hr>\n<p>哦？看起来要写很多代码！这是因为，通用数据预取可能是服务器渲染应用程序中最复杂的问题，我们正在为下一步开发做前期准备。一旦设定好模板示例，创建单独组件实际上会变得相当轻松。</p>\n'},168:function(e,n){e.exports='<h1 id="head-管理">Head 管理</h1>\n<p>类似于资源注入，Head 管理遵循相同的理念：我们可以在组件的生命周期中，将数据动态地追加到渲染<code>上下文</code> (render <code>context</code>)，然后在<code>模板</code>中的占位符替换为这些数据。</p>\n<blockquote>\n<p>在 2.3.2+ 的版本，你可以通过 <code>this.$ssrContext</code> 来直接访问组件中的服务器端渲染上下文(SSR context)。在旧版本中，你必须通过将其传递给 <code>createApp()</code> 并将其暴露于根实例的 <code>$options</code> 上，才能手动注入服务器端渲染上下文(SSR context) - 然后子组件可以通过 <code>this.$root.$options.ssrContext</code> 来访问它。</p>\n</blockquote>\n<p>我们可以编写一个简单的 mixin 来完成标题管理：</p>\n<pre><code class="language-js">// title-mixin.js\n\nfunction getTitle (vm) {\n  // 组件可以提供一个 `title` 选项\n  // 此选项可以是一个字符串或函数\n  const { title } = vm.$options\n  if (title) {\n    return typeof title === &#39;function&#39;\n      ? title.call(vm)\n      : title\n  }\n}\n\nconst serverTitleMixin = {\n  created () {\n    const title = getTitle(this)\n    if (title) {\n      this.$ssrContext.title = title\n    }\n  }\n}\n\nconst clientTitleMixin = {\n  mounted () {\n    const title = getTitle(this)\n    if (title) {\n      document.title = title\n    }\n  }\n}\n\n// 可以通过 `webpack.DefinePlugin` 注入 `VUE_ENV`\nexport default process.env.VUE_ENV === &#39;server&#39;\n  ? serverTitleMixin\n  : clientTitleMixin</code></pre>\n<p>现在，路由组件可以利用以上 mixin，来控制文档标题 (document title)：</p>\n<pre><code class="language-js">// Item.vue\nexport default {\n  mixins: [titleMixin],\n  title () {\n    return this.item.title\n  },\n\n  asyncData ({ store, route }) {\n    return store.dispatch(&#39;fetchItem&#39;, route.params.id)\n  },\n\n  computed: {\n    item () {\n      return this.$store.state.items[this.$route.params.id]\n    }\n  }\n}</code></pre>\n<p>然后模板中的内容将会传递给 bundle renderer：</p>\n<pre><code class="language-html">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;{{ title }}&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation)，以避免 XSS 攻击。</p>\n</li>\n<li><p>你应该在创建 <code>context</code> 对象时提供一个默认标题，以防在渲染过程中组件没有设置标题。</p>\n</li>\n</ul>\n<hr>\n<p>使用相同的策略，你可以轻松地将此 mixin 扩展为通用的头部管理工具 (generic head management utility)。</p>\n'},169:function(e,n){e.exports='<h1 id="客户端激活-client-side-hydration">客户端激活 (client-side hydration)</h1>\n<p>所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。</p>\n<p>在 <code>entry-client.js</code> 中，我们用下面这行挂载(mount)应用程序：</p>\n<pre><code class="language-js">// 这里假定 App.vue template 根元素的 `id=&quot;app&quot;`\napp.$mount(&#39;#app&#39;)</code></pre>\n<p>由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要&quot;激活&quot;这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。</p>\n<p>如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性：</p>\n<pre><code class="language-html">&lt;div id=&quot;app&quot; data-server-rendered=&quot;true&quot;&gt;</code></pre>\n<p><code>data-server-rendered</code> 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载。注意，这里并没有添加 <code>id=&quot;app&quot;</code>，而是添加 <code>data-server-rendered</code> 属性：你需要自行添加 ID 或其他能够选取到应用程序根元素的选择器，否则应用程序将无法正常激活。</p>\n<p>注意，在没有 <code>data-server-rendered</code> 属性的元素上，还可以向 <code>$mount</code> 函数的 <code>hydrating</code> 参数位置传入 <code>true</code>，来强制使用激活模式(hydration)：</p>\n<pre><code class="language-js">// 强制使用应用程序的激活模式\napp.$mount(&#39;#app&#39;, true)</code></pre>\n<p>在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树 (virtual DOM tree)，是否与从服务器渲染的 DOM 结构 (DOM structure) 匹配。如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。<strong>在生产模式下，此检测会被跳过，以避免性能损耗。</strong></p>\n<h3 id="一些需要注意的坑">一些需要注意的坑</h3>\n<p>使用「SSR + 客户端混合」时，需要了解的一件事是，浏览器可能会更改的一些特殊的 HTML 结构。例如，当你在 Vue 模板中写入：</p>\n<pre><code class="language-html">&lt;table&gt;\n  &lt;tr&gt;&lt;td&gt;hi&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;</code></pre>\n<p>浏览器会在 <code>&lt;table&gt;</code> 内部自动注入 <code>&lt;tbody&gt;</code>，然而，由于 Vue 生成的虚拟 DOM (virtual DOM) 不包含 <code>&lt;tbody&gt;</code>，所以会导致无法匹配。为能够正确匹配，请确保在模板中写入有效的 HTML。</p>\n'},170:function(e,n){e.exports='<h1 id="在非-nodejs-环境中使用">在非 Node.js 环境中使用</h1>\n<p><code>vue-server-renderer</code> 在默认构建时，会预先假定有一个 Node.js 环境，这使得它在其他 JavaScript 环境（如 <a href="https://github.com/phpv8/v8js">PHP V8Js</a> 或 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/">Oracle Nashorn</a> 中无法使用。在 2.5+ 版本中，我们把那些基本上与环境无关的构建，编译到 <code>vue-server-renderer/basic.js</code> 中，这使得它可以在上述环境中使用。</p>\n<p>对于所有环境，必须要预先在环境中模拟 <code>global</code> 和 <code>process</code> 对象，以及将 <code>process.env.VUE_ENV</code> 设置为 <code>&quot;server&quot;</code> 和将 <code>process.env.NODE_ENV</code> 设置为 <code>&quot;development&quot;</code> 或 <code>&quot;production&quot;</code>。</p>\n<p>在 Nashorn 环境下，可能还需要使用 Java 原生定时器，来为 <code>Promise</code> 或 <code>setTimeout</code> 提供 polyfill。</p>\n<p>php-v8js 的示例用法：</p>\n<pre><code class="language-php">&lt;?php\n$vue_source = file_get_contents(&#39;/path/to/vue.js&#39;);\n$renderer_source = file_get_contents(&#39;/path/to/vue-server-renderer/basic.js&#39;);\n$app_source = file_get_contents(&#39;/path/to/app.js&#39;);\n\n$v8 = new V8Js();\n\n$v8-&gt;executeString(&#39;var process = { env: { VUE_ENV: &quot;server&quot;, NODE_ENV: &quot;production&quot; }}; this.global = { process: process };&#39;);\n$v8-&gt;executeString($vue_source);\n$v8-&gt;executeString($renderer_source);\n$v8-&gt;executeString($app_source);\n?&gt;</code></pre>\n<hr>\n<pre><code class="language-js">// app.js\nvar vm = new Vue({\n  template: `&lt;div&gt;{{ msg }}&lt;/div&gt;`,\n  data: {\n    msg: &#39;hello&#39;\n  }\n})\n\n// 通过 `vue-server-renderer/basic.js` 暴露\nrenderVueComponentToString(vm, (err, res) =&gt; {\n  print(res)\n})</code></pre>\n'},171:function(e,n){e.exports='<h1 id="路由和代码分割">路由和代码分割</h1>\n<h2 id="使用-vue-router-的路由">使用 <code>vue-router</code> 的路由</h2>\n<p>你可能已经注意到，我们的服务器代码使用了一个 <code>*</code> 处理程序，它接受任意 URL。这允许我们将访问的 URL 传递到我们的 Vue 应用程序中，然后对客户端和服务器复用相同的路由配置！</p>\n<p>为此，建议使用官方提供的 <code>vue-router</code>。我们首先创建一个文件，在其中创建 router。注意，类似于 <code>createApp</code>，我们也需要给每个请求一个新的 router 实例，所以文件导出一个 <code>createRouter</code> 函数：</p>\n<pre><code class="language-js">// router.js\nimport Vue from &#39;vue&#39;\nimport Router from &#39;vue-router&#39;\n\nVue.use(Router)\n\nexport function createRouter () {\n  return new Router({\n    mode: &#39;history&#39;,\n    routes: [\n      // ...\n    ]\n  })\n}</code></pre>\n<p>然后更新 <code>app.js</code>:</p>\n<pre><code class="language-js">// app.js\nimport Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport { createRouter } from &#39;./router&#39;\n\nexport function createApp () {\n  // 创建 router 实例\n  const router = createRouter()\n\n  const app = new Vue({\n    // 注入 router 到根 Vue 实例\n    router,\n    render: h =&gt; h(App)\n  })\n\n  // 返回 app 和 router\n  return { app, router }\n}</code></pre>\n<p>现在我们需要在 <code>entry-server.js</code> 中实现服务器端路由逻辑 (server-side routing logic)：</p>\n<pre><code class="language-js">// entry-server.js\nimport { createApp } from &#39;./app&#39;\n\nexport default context =&gt; {\n  // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise，\n    // 以便服务器能够等待所有的内容在渲染前，\n    // 就已经准备就绪。\n  return new Promise((resolve, reject) =&gt; {\n    const { app, router } = createApp()\n\n    // 设置服务器端 router 的位置\n    router.push(context.url)\n\n    // 等到 router 将可能的异步组件和钩子函数解析完\n    router.onReady(() =&gt; {\n      const matchedComponents = router.getMatchedComponents()\n      // 匹配不到的路由，执行 reject 函数，并返回 404\n      if (!matchedComponents.length) {\n        return reject({ code: 404 })\n      }\n\n      // Promise 应该 resolve 应用程序实例，以便它可以渲染\n      resolve(app)\n    }, reject)\n  })\n}</code></pre>\n<p>假设服务器 bundle 已经完成构建（请再次忽略现在的构建设置），服务器用法看起来如下：</p>\n<pre><code class="language-js">// server.js\nconst createApp = require(&#39;/path/to/built-server-bundle.js&#39;)\n\nserver.get(&#39;*&#39;, (req, res) =&gt; {\n  const context = { url: req.url }\n\n  createApp(context).then(app =&gt; {\n    renderer.renderToString(app, (err, html) =&gt; {\n      if (err) {\n        if (err.code === 404) {\n          res.status(404).end(&#39;Page not found&#39;)\n        } else {\n          res.status(500).end(&#39;Internal Server Error&#39;)\n        }\n      } else {\n        res.end(html)\n      }\n    })\n  })\n})</code></pre>\n<h2 id="代码分割">代码分割</h2>\n<p>应用程序的代码分割或惰性加载，有助于减少浏览器在初始渲染中下载的资源体积，可以极大地改善大体积 bundle 的可交互时间(TTI - time-to-interactive)。这里的关键在于，对初始首屏而言，&quot;只加载所需&quot;。</p>\n<p>Vue 提供异步组件作为第一类的概念，将其与 <a href="https://webpack.js.org/guides/code-splitting-async/">webpack 2 所支持的使用动态导入作为代码分割点</a>相结合，你需要做的是：</p>\n<pre><code class="language-js">// 这里进行修改……\nimport Foo from &#39;./Foo.vue&#39;\n\n// 改为这样：\nconst Foo = () =&gt; import(&#39;./Foo.vue&#39;)</code></pre>\n<p>在 Vue 2.5 以下的版本中，服务端渲染时异步组件只能用在路由组件上。然而在 2.5+ 的版本中，得益于核心算法的升级，异步组件现在可以在应用中的任何地方使用。</p>\n<p>需要注意的是，你仍然需要在挂载 app 之前调用 <code>router.onReady</code>，因为路由器必须要提前解析路由配置中的异步组件，才能正确地调用组件中可能存在的路由钩子。这一步我们已经在我们的服务器入口 (server entry) 中实现过了，现在我们只需要更新客户端入口 (client entry)：</p>\n<pre><code class="language-js">// entry-client.js\n\nimport { createApp } from &#39;./app&#39;\n\nconst { app, router } = createApp()\n\nrouter.onReady(() =&gt; {\n  app.$mount(&#39;#app&#39;)\n})</code></pre>\n<p>异步路由组件的路由配置示例：</p>\n<pre><code class="language-js">// router.js\nimport Vue from &#39;vue&#39;\nimport Router from &#39;vue-router&#39;\n\nVue.use(Router)\n\nexport function createRouter () {\n  return new Router({\n    mode: &#39;history&#39;,\n    routes: [\n      { path: &#39;/&#39;, component: () =&gt; import(&#39;./components/Home.vue&#39;) },\n      { path: &#39;/item/:id&#39;, component: () =&gt; import(&#39;./components/Item.vue&#39;) }\n    ]\n  })\n}</code></pre>\n'},172:function(e,n){e.exports='<h1 id="流式渲染-streaming">流式渲染 (Streaming)</h1>\n<p>对于 <code>vue-server-renderer</code> 的基本 renderer 和 bundle renderer 都提供开箱即用的流式渲染功能。所有你需要做的就是，用 <code>renderToStream</code> 替代 <code>renderToString</code>：</p>\n<pre><code class="language-js">const stream = renderer.renderToStream(context)</code></pre>\n<p>返回的值是 <a href="https://nodejs.org/api/stream.html">Node.js stream</a>：</p>\n<pre><code class="language-js">let html = &#39;&#39;\n\nstream.on(&#39;data&#39;, data =&gt; {\n  html += data.toString()\n})\n\nstream.on(&#39;end&#39;, () =&gt; {\n  console.log(html) // 渲染完成\n})\n\nstream.on(&#39;error&#39;, err =&gt; {\n  // handle error...\n})</code></pre>\n<h2 id="流式传输说明-streaming-caveats">流式传输说明 (Streaming Caveats)</h2>\n<p>在流式渲染模式下，当 renderer 遍历虚拟 DOM 树 (virtual DOM tree) 时，会尽快发送数据。这意味着我们可以尽快获得&quot;第一个 chunk&quot;，并开始更快地将其发送给客户端。</p>\n<p>然而，当第一个数据 chunk 被发出时，子组件甚至可能不被实例化，它们的生命周期钩子也不会被调用。这意味着，如果子组件需要在其生命周期钩子函数中，将数据附加到渲染上下文 (render context)，当流 (stream) 启动时，这些数据将不可用。这是因为，大量上下文信息 (context information)（如头信息 (head information) 或内联关键 CSS(inline critical CSS)）需要在应用程序标记 (markup) 之前出现，我们基本上必须等待流(stream)完成后，才能开始使用这些上下文数据。</p>\n<p>因此，如果你依赖由组件生命周期钩子函数填充的上下文数据，则<strong>不建议</strong>使用流式传输模式。</p>\n'},173:function(e,n){e.exports='<h1 id="源码结构">源码结构</h1>\n<h2 id="避免状态单例">避免状态单例</h2>\n<p>当编写纯客户端 (client-only) 代码时，我们习惯于每次在新的上下文中对代码进行取值。但是，Node.js 服务器是一个长期运行的进程。当我们的代码进入该进程时，它将进行一次取值并留存在内存中。这意味着如果创建一个单例对象，它将在每个传入的请求之间共享。</p>\n<p>如基本示例所示，我们<strong>为每个请求创建一个新的根 Vue 实例</strong>。这与每个用户在自己的浏览器中使用新应用程序的实例类似。如果我们在多个请求之间使用一个共享的实例，很容易导致交叉请求状态污染 (cross-request state pollution)。</p>\n<p>因此，我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例：</p>\n<pre><code class="language-js">// app.js\nconst Vue = require(&#39;vue&#39;)\n\nmodule.exports = function createApp (context) {\n  return new Vue({\n    data: {\n      url: context.url\n    },\n    template: `&lt;div&gt;访问的 URL 是： {{ url }}&lt;/div&gt;`\n  })\n}</code></pre>\n<p>并且我们的服务器代码现在变为：</p>\n<pre><code class="language-js">// server.js\nconst createApp = require(&#39;./app&#39;)\n\nserver.get(&#39;*&#39;, (req, res) =&gt; {\n  const context = { url: req.url }\n  const app = createApp(context)\n\n  renderer.renderToString(app, (err, html) =&gt; {\n    // 处理错误……\n    res.end(html)\n  })\n})</code></pre>\n<p>同样的规则也适用于 router、store 和 event bus 实例。你不应该直接从模块导出并将其导入到应用程序中，而是需要在 <code>createApp</code> 中创建一个新的实例，并从根 Vue 实例注入。</p>\n<blockquote>\n<p>在使用带有 <code>{ runInNewContext: true }</code> 的 bundle renderer 时，可以消除此约束，但是由于需要为每个请求创建一个新的 vm 上下文，因此伴随有一些显著性能开销。</p>\n</blockquote>\n<h2 id="介绍构建步骤">介绍构建步骤</h2>\n<p>到目前为止，我们还没有讨论过如何将相同的 Vue 应用程序提供给客户端。为了做到这一点，我们需要使用 webpack 来打包我们的 Vue 应用程序。事实上，我们可能需要在服务器上使用 webpack 打包 Vue 应用程序，因为：</p>\n<ul>\n<li><p>通常 Vue 应用程序是由 webpack 和 <code>vue-loader</code> 构建，并且许多 webpack 特定功能不能直接在 Node.js 中运行（例如通过 <code>file-loader</code> 导入文件，通过 <code>css-loader</code> 导入 CSS）。</p>\n</li>\n<li><p>尽管 Node.js 最新版本能够完全支持 ES2015 特性，我们还是需要转译客户端代码以适应老版浏览器。这也会涉及到构建步骤。</p>\n</li>\n</ul>\n<p>所以基本看法是，对于客户端应用程序和服务器应用程序，我们都要使用 webpack 打包 - 服务器需要「服务器 bundle」然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记。</p>\n<p><img src="https://cloud.githubusercontent.com/assets/499550/17607895/786a415a-5fee-11e6-9c11-45a2cfdf085c.png" alt="架构"></p>\n<p>我们将在后面的章节讨论规划结构的细节 - 现在，先假设我们已经将构建过程的规划都弄清楚了，我们可以在启用 webpack 的情况下编写我们的 Vue 应用程序代码。</p>\n<h2 id="使用-webpack-的源码结构">使用 webpack 的源码结构</h2>\n<p>现在我们正在使用 webpack 来处理服务器和客户端的应用程序，大部分源码可以使用通用方式编写，可以使用 webpack 支持的所有功能。同时，在编写通用代码时，有一些<a href="./universal.md">事项</a>要牢记在心。</p>\n<p>一个基本项目可能像是这样：</p>\n<pre><code class="language-bash">src\n├── components\n│   ├── Foo.vue\n│   ├── Bar.vue\n│   └── Baz.vue\n├── App.vue\n├── app.js # 通用 entry(universal entry)\n├── entry-client.js # 仅运行于浏览器\n└── entry-server.js # 仅运行于服务器</code></pre>\n<h3 id="appjs"><code>app.js</code></h3>\n<p><code>app.js</code> 是我们应用程序的「通用 entry」。在纯客户端应用程序中，我们将在此文件中创建根 Vue 实例，并直接挂载到 DOM。但是，对于服务器端渲染(SSR)，责任转移到纯客户端 entry 文件。<code>app.js</code> 简单地使用 export 导出一个 <code>createApp</code> 函数：</p>\n<pre><code class="language-js">import Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\n\n// 导出一个工厂函数，用于创建新的\n// 应用程序、router 和 store 实例\nexport function createApp () {\n  const app = new Vue({\n    // 根实例简单的渲染应用程序组件。\n    render: h =&gt; h(App)\n  })\n  return { app }\n}</code></pre>\n<h3 id="entry-clientjs"><code>entry-client.js</code>:</h3>\n<p>客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中：</p>\n<pre><code class="language-js">import { createApp } from &#39;./app&#39;\n\n// 客户端特定引导逻辑……\n\nconst { app } = createApp()\n\n// 这里假定 App.vue 模板中根元素具有 `id=&quot;app&quot;`\napp.$mount(&#39;#app&#39;)</code></pre>\n<h3 id="entry-serverjs"><code>entry-server.js</code>:</h3>\n<p>服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情 - 但是稍后我们将在此执行服务器端路由匹配 (server-side route matching) 和数据预取逻辑 (data pre-fetching logic)。</p>\n<pre><code class="language-js">import { createApp } from &#39;./app&#39;\n\nexport default context =&gt; {\n  const { app } = createApp()\n  return app\n}</code></pre>\n'},174:function(e,n){e.exports='<h1 id="编写通用代码">编写通用代码</h1>\n<p>在进一步介绍之前，让我们花点时间来讨论编写&quot;通用&quot;代码时的约束条件 - 即运行在服务器和客户端的代码。由于用例和平台 API 的差异，当运行在不同环境中时，我们的代码将不会完全相同。所以这里我们将会阐述你需要理解的关键事项。</p>\n<h2 id="服务器上的数据响应">服务器上的数据响应</h2>\n<p>在纯客户端应用程序 (client-only app) 中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染 (cross-request state pollution)。</p>\n<p>因为实际的渲染过程需要确定性，所以我们也将在服务器上“预取”数据 (&quot;pre-fetching&quot; data) - 这意味着在我们开始渲染时，我们的应用程序就已经解析完成其状态。也就是说，将数据进行响应式的过程在服务器上是多余的，所以默认情况下禁用。禁用响应式数据，还可以避免将「数据」转换为「响应式对象」的性能开销。</p>\n<h2 id="组件生命周期钩子函数">组件生命周期钩子函数</h2>\n<p>由于没有动态更新，所有的生命周期钩子函数中，只有 <code>beforeCreate</code> 和 <code>created</code> 会在服务器端渲染 (SSR) 过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 <code>beforeMount</code> 或 <code>mounted</code>），只会在客户端执行。</p>\n<p>此外还需要注意的是，你应该避免在 <code>beforeCreate</code> 和 <code>created</code> 生命周期时产生全局副作用的代码，例如在其中使用 <code>setInterval</code> 设置 timer。在纯客户端 (client-side only) 的代码中，我们可以设置一个 timer，然后在 <code>beforeDestroy</code> 或 <code>destroyed</code> 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，请将副作用代码移动到 <code>beforeMount</code> 或 <code>mounted</code> 生命周期中。</p>\n<h2 id="访问特定平台platform-specific-api">访问特定平台(Platform-Specific) API</h2>\n<p>通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 <code>window</code> 或 <code>document</code>，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。</p>\n<p>对于共享于服务器和客户端，但用于不同平台 API 的任务(task)，建议将平台特定实现包含在通用 API 中，或者使用为你执行此操作的 library。例如，<a href="https://github.com/axios/axios">axios</a> 是一个 HTTP 客户端，可以向服务器和客户端都暴露相同的 API。</p>\n<p>对于仅浏览器可用的 API，通常方式是，在「纯客户端 (client-only)」的生命周期钩子函数中惰性访问 (lazily access) 它们。</p>\n<p>请注意，考虑到如果第三方 library 不是以上面的通用用法编写，则将其集成到服务器渲染的应用程序中，可能会很棘手。你<em>可能</em>要通过模拟 (mock) 一些全局变量来使其正常运行，但这只是 hack 的做法，并且可能会干扰到其他 library 的环境检测代码。</p>\n<h2 id="自定义指令">自定义指令</h2>\n<p>大多数自定义指令直接操作 DOM，因此会在服务器端渲染 (SSR) 过程中导致错误。有两种方法可以解决这个问题：</p>\n<ol>\n<li><p>推荐使用组件作为抽象机制，并运行在「虚拟 DOM 层级(Virtual-DOM level)」（例如，使用渲染函数(render function)）。</p>\n</li>\n<li><p>如果你有一个自定义指令，但是不是很容易替换为组件，则可以在创建服务器 renderer 时，使用 <a href="../api/#directives"><code>directives</code></a> 选项所提供&quot;服务器端版本(server-side version)&quot;。</p>\n</li>\n</ol>\n'},175:function(e,n,t){"use strict";var r=t(150);t.n(r).a},176:function(e,n,t){(n=t(69)(!1)).push([e.i,".doc-container[data-v-b2512a50]{padding-bottom:50px}",""]),e.exports=n},177:function(e,n,t){"use strict";t.r(n);t(151);var r=t(153),o=t.n(r),c=(t(154),{name:"Pager",props:{total:{type:Number,default:null},currentPage:{type:Number,default:1}}}),d=(t(157),t(22)),l=Object(d.a)(c,(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"controls"},[e.currentPage>1?t("nuxt-link",{attrs:{to:"/"+(e.currentPage-1)}},[t("button",{staticClass:"btn prev",attrs:{disabled:e.currentPage<2}},[e._v("\n      上一页\n    ")])]):t("button",{staticClass:"btn prev",attrs:{disabled:e.currentPage<2}},[e._v("\n    上一页\n  ")]),e._v(" "),e.currentPage<e.total?t("nuxt-link",{attrs:{to:"/"+(e.currentPage+1)}},[t("button",{staticClass:"btn next",attrs:{disabled:e.currentPage>=e.total}},[e._v("\n      下一页\n    ")])]):t("button",{staticClass:"btn next",attrs:{disabled:e.currentPage>=e.total}},[e._v("\n    下一页\n  ")])],1)}),[],!1,null,"9a4e02f8",null).exports;t(26),t(16),t(72),t(73);function h(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"README.md";return e.map((function(e){return"/"===e[e.length-1]&&(e+=n),e}))}var m,v=h(["/zh/","/zh/guide/","/zh/guide/universal","/zh/guide/structure","/zh/guide/routing","/zh/guide/data","/zh/guide/hydration","/zh/guide/bundle-renderer","/zh/guide/build-config","/zh/guide/css","/zh/guide/head","/zh/guide/caching","/zh/guide/streaming","/zh/guide/non-node"]),f=(h(["/zh/api/"]),t(159)),S=f.keys(),x=(m=S,v.forEach((function(e,n){for(var i=n;i<m.length;i++){var t=m[i];if(t.includes(e)){var r=m[n];m[n]=t,m[i]=r}}})),m).map(f),j={sourceIndex:0,source:x[0]},y={name:"Chapter",components:{Pager:l},asyncData:function(e){var n=e.route.params.chapter,t=parseInt(n);return!t||isNaN(t)||t>x.length?(e.error({statusCode:404,message:"Page not Found"}),j):{sourceIndex:t-1,sourceLength:x.length,source:x[t-1]}},mounted:function(){o.a.highlightAll()}},k=(t(175),Object(d.a)(y,(function(){var e=this.$createElement,n=this._self._c||e;return n("section",{staticClass:"doc-container"},[n("div",{domProps:{innerHTML:this._s(this.source)}}),this._v(" "),n("pager",{attrs:{"current-page":this.sourceIndex+1,total:this.sourceLength}})],1)}),[],!1,null,"b2512a50",null));n.default=k.exports}}]);